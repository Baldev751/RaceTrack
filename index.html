<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Local Multiplayer Racetrack Challenge</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom font for a more modern look */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    canvas {
      background-color: #f8f8f8; /* Light background for the track */
      display: block;
      margin: 20px auto;
      border: 2px solid #333; /* Stronger border for the canvas */
      border-radius: 8px; /* Rounded corners for the canvas */
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }
    /* Styles for the custom message box */
    .message-box-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .message-box-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 400px;
      width: 90%;
      transform: scale(0.95);
      opacity: 0;
      animation: fadeInScale 0.2s forwards;
    }
    @keyframes fadeInScale {
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
    /* Disabled button styling */
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none; /* Remove hover transform for disabled */
    }
    button:disabled:hover {
        background-color: #4F46E5; /* Keep original background for disabled hover */
    }
    .player-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      vertical-align: middle;
    }
    .track-selection-item {
        border: 2px solid transparent;
        transition: all 0.2s ease-in-out;
    }
    .track-selection-item.selected {
        border-color: #4F46E5; /* Indigo-600 for selected track */
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.5); /* Ring effect */
        transform: scale(1.02);
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-100 to-purple-100 min-h-screen flex flex-col items-center py-8">

  <!-- Setup Screen -->
  <div id="setupScreen" class="bg-white p-8 rounded-lg shadow-xl w-11/12 max-w-2xl flex flex-col items-center">
    <h2 class="text-3xl font-bold text-gray-800 mb-6">Game Setup</h2>

    <!-- Player Management -->
    <div class="mb-8 w-full">
      <h3 class="text-2xl font-semibold text-gray-700 mb-4">Players (<span id="playerCount">0</span>/4)</h3>
      <div id="stagedPlayersContainer" class="flex flex-wrap justify-center gap-x-4 gap-y-2 mb-4">
        </div>
      <div class="flex justify-center gap-4">
        <button id="addPlayerButton" onclick="addPlayer()" class="px-6 py-2 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition duration-200">Add Player</button>
        <button id="removePlayerButton" onclick="removePlayer()" class="px-6 py-2 bg-red-500 text-white font-bold rounded-lg shadow-md hover:bg-red-600 transition duration-200">Remove Player</button>
      </div>
    </div>

    <!-- Track Selection -->
    <div class="w-full">
      <h3 class="text-2xl font-semibold text-gray-700 mb-4">Select Track</h3>
      <div id="trackSelectionContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
        </div>
    </div>

    <button onclick="startGame()" class="px-10 py-4 bg-blue-600 text-white font-bold text-xl rounded-lg shadow-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105">Start Race! üèÅ</button>
  </div>

  <!-- Game Screen (initially hidden) -->
  <div id="gameScreen" class="hidden flex flex-col items-center w-full">
    <div class="bg-white p-6 rounded-lg shadow-lg mb-6 w-11/12 max-w-lg">
      <div id="gameInfo" class="text-center mb-4">
        <div id="playerList" class="mt-4">
          <h3 class="font-bold text-gray-800 mb-2">Players:</h3>
          <ul id="playersContainer" class="list-none p-0 flex flex-wrap justify-center gap-x-4 gap-y-2">
            </ul>
        </div>
        <p id="currentTurnInfo" class="text-xl font-bold mt-4">Player 1's Turn!</p>
        <p id="gameStatusInfo" class="text-lg font-medium text-gray-700 mt-2">Status: Playing</p>
      </div>
    </div>

    <canvas id="track" width="900" height="600" class="max-w-full h-auto"></canvas>

    <div id="velocity" class="text-xl font-semibold text-gray-700 mt-4">Current Player's Velocity: (0, 0)</div>

    <div id="controls" class="flex flex-wrap justify-center gap-3 mt-8">
      <button id="vxMinus" onclick="changeVX(-1)" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out transform hover:scale-105">‚óÄÔ∏è VX -1</button>
      <button id="vxPlus" onclick="changeVX(1)" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out transform hover:scale-105">‚ñ∂Ô∏è VX +1</button>
      <button id="vyMinus" onclick="changeVY(-1)" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out transform hover:scale-105">üîΩ VY -1</button>
      <button id="vyPlus" onclick="changeVY(1)" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out transform hover:scale-105">üîº VY +1</button>
      <button id="moveButton" onclick="movePlayer()" class="px-8 py-3 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600 transition duration-200 ease-in-out transform hover:scale-105 ml-4">üöÄ Move</button>
      <button id="resetButton" onclick="resetGame()" class="px-8 py-3 bg-red-500 text-white font-bold rounded-lg shadow-lg hover:bg-red-600 transition duration-200 ease-in-out transform hover:scale-105">üîÑ Reset Game</button>
    </div>
  </div>

  <!-- Custom Message Box -->
  <div id="messageBoxOverlay" class="message-box-overlay hidden">
    <div id="messageBoxContent" class="message-box-content">
      <p id="messageBoxText" class="text-lg font-medium text-gray-800 mb-6"></p>
      <button onclick="hideMessageBox()" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 ease-in-out transform hover:scale-105">OK</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("track");
    const ctx = canvas.getContext("2d");
    const gridSize = 30; // Size of each grid cell in pixels
    const cols = canvas.width / gridSize; // Number of columns in the grid
    const rows = canvas.height / gridSize; // Number of rows in the grid

    // Player colors for multiplayer
    const playerColors = [
      "#3B82F6", // Player 1: Blue
      "#EF4444", // Player 2: Red
      "#10B981", // Player 3: Green
      "#F59E0B"  // Player 4: Amber
    ];

    // --- Helper Functions for Track Drawing ---

    /**
     * Fills the entire inner playable area with blocks (walls).
     * This is the inverse logic for creating paths by unblocking.
     */
    function fillInnerTrackWalls() {
        for (let x = 2; x < cols - 2; x++) {
            for (let y = 2; y < rows - 2; y++) {
                blockedCells.add(cellKey(x, y));
            }
        }
    }

    /**
     * Unblocks a rectangular area, creating a path.
     * @param {number} startX - Starting X-coordinate (grid units).
     * @param {number} startY - Starting Y-coordinate (grid units).
     * @param {number} width - Width of the rectangle (grid units).
     * @param {number} height - Height of the rectangle (grid units).
     */
    function unblockRectangle(startX, startY, width, height) {
        for (let x = startX; x < startX + width; x++) {
            for (let y = startY; y < startY + height; y++) {
                blockedCells.delete(cellKey(x, y));
            }
        }
    }

    /**
     * Unblocks a diagonal line segment with a given thickness, ensuring a solid path.
     * @param {number} x0 - Start X-coordinate.
     * @param {number} y0 - Start Y-coordinate.
     * @param {number} x1 - End X-coordinate.
     * @param {number} y1 - End Y-coordinate.
     * @param {number} thickness - How many grid units thick the line should be.
     */
    function unblockDiagonal(x0, y0, x1, y1, thickness = 1) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;

        let currentX = x0;
        let currentY = y0;

        while (true) {
            // Unblock a small rectangle at current position, covering thickness
            for (let i = 0; i < thickness; i++) {
                for (let j = 0; j < thickness; j++) {
                    blockedCells.delete(cellKey(currentX + i, currentY + j));
                }
            }

            if (currentX === x1 && currentY === y1) break;

            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; currentX += sx; }
            if (e2 < dx) { err += dx; currentY += sy; }
        }
    }

    /**
     * Helper function to define the core playable area bounds.
     */
    function getPlayableAreaBounds() {
        const playableMinX = 2;
        const playableMaxX = cols - 3; // Right before the right boundary
        const playableMinY = 2;
        const playableMaxY = rows - 3; // Right before the bottom boundary
        return { playableMinX, playableMaxX, playableMinY, playableMaxY };
    }

    /**
     * Draws Start/Finish lines and text for alphabet tracks.
     * @param {object} startLine - {x0, y0, x1, y1, type}
     * @param {object} finishLine - {x0, y0, x1, y1, type}
     */
    function drawTrackLinesAndTexts(startLine, finishLine) {
        // Draw Start Line
        ctx.strokeStyle = "#10B981"; // Green
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(startLine.x0 * gridSize, startLine.y0 * gridSize);
        ctx.lineTo(startLine.x1 * gridSize, startLine.y1 * gridSize);
        ctx.stroke();

        ctx.font = "14px Inter";
        ctx.fillStyle = "#10B981";
        // Position "START" text relative to the start line
        if (startLine.type === 'horizontal') {
            // Adjust text position slightly below the line if it's a top start line
            // or slightly above if it's a bottom start line.
            const textYOffset = (startLine.y0 < (rows / 2)) ? 15 : -5;
            ctx.fillText("START", (startLine.x0 + (startLine.x1 - startLine.x0) / 2) * gridSize - 20, startLine.y0 * gridSize + textYOffset);
        } else { // vertical
            ctx.fillText("START", (startLine.x0 + 0.5) * gridSize, (startLine.y0 + 1) * gridSize);
        }


        // Draw Finish Line
        ctx.strokeStyle = "#EF4444"; // Red
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(finishLine.x0 * gridSize, finishLine.y0 * gridSize);
        ctx.lineTo(finishLine.x1 * gridSize, finishLine.y1 * gridSize);
        ctx.stroke();

        ctx.font = "14px Inter";
        ctx.fillStyle = "#EF4444";
        // Position "FINISH" text relative to the finish line
        if (finishLine.type === 'horizontal') {
             // Adjust text position slightly below the line if it's a top finish line
            // or slightly above if it's a bottom finish line.
            const textYOffset = (finishLine.y0 < (rows / 2)) ? 15 : -5;
            ctx.fillText("FINISH", (finishLine.x0 + (finishLine.x1 - finishLine.x0) / 2) * gridSize - 20, finishLine.y0 * gridSize + textYOffset);
        } else { // vertical
            ctx.fillText("FINISH", (finishLine.x1 + 0.5) * gridSize - 50, (finishLine.y1 + 1) * gridSize);
        }
    }


    // --- Track Definitions ---
    // Each track object contains a name and a function to draw its unique layout.
    // The draw function will clear existing blockedCells and add new blocks/unblocks.
    // It should also return the startLine and finishLine properties for player placement.
    const trackDefinitions = [
        {
            id: 'simple-sprint',
            name: 'Simple Sprint',
            description: 'A straightforward track with a wide, clear path.',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill entire inner playable area with walls first
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                // Unblock a wide, straight path that connects start and finish
                unblockRectangle(playableMinX, playableMinY, playableMaxX - playableMinX + 1, playableMaxY - playableMinY + 1);

                // Define Start and Finish Line coordinates for this track
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMaxY, type: 'vertical' };
                const finishLine = { x0: playableMaxX, y0: playableMinY, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine }; // Return line info for player placement
            }
        },
        {
            id: 'z-track',
            name: 'Z-Track',
            description: 'Navigate a challenging Z-shaped path (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill entire inner playable area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4; // Changed from 3 to 4 as requested
                const letterWidth = playableMaxX - playableMinX + 1;

                // Top horizontal bar of Z
                unblockRectangle(playableMinX, playableMinY, letterWidth, pathWidth);

                // Diagonal stroke (from top-right to bottom-left)
                unblockDiagonal(playableMaxX - pathWidth + 1, playableMinY, playableMinX, playableMaxY - pathWidth + 1, pathWidth);

                // Bottom horizontal bar of Z
                unblockRectangle(playableMinX, playableMaxY - pathWidth + 1, letterWidth, pathWidth);

                // Define Start and Finish Line coordinates for Z-Track
                // Start line: Vertical, at playableMinX, covering the top horizontal bar's height
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMinY + pathWidth -1, type: 'vertical' };
                // Finish line: Vertical, at playableMaxX, covering the bottom horizontal bar's height
                const finishLine = { x0: playableMaxX, y0: playableMaxY - pathWidth + 1, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'h-track',
            name: 'H-Track',
            description: 'Race through an H-shaped track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4; // Path width of 4 as requested
                const letterWidth = playableMaxX - playableMinX + 1;
                const letterHeight = playableMaxY - playableMinY + 1;

                // Left vertical bar
                unblockRectangle(playableMinX, playableMinY, pathWidth, letterHeight);

                // Right vertical bar
                unblockRectangle(playableMaxX - pathWidth + 1, playableMinY, pathWidth, letterHeight);

                // Horizontal connecting bar (middle)
                unblockRectangle(playableMinX, Math.floor(playableMinY + letterHeight / 2) - Math.floor(pathWidth / 2), letterWidth, pathWidth);

                // Define Start and Finish Line coordinates for H-Track
                // Start line: Horizontal, at the top of the left vertical bar
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX + pathWidth -1, y1: playableMinY, type: 'horizontal' };
                // Finish line: Horizontal, at the bottom of the right vertical bar
                const finishLine = { x0: playableMaxX - pathWidth + 1, y0: playableMaxY, x1: playableMaxX, y1: playableMaxY, type: 'horizontal' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'u-track',
            name: 'U-Track',
            description: 'Turn around a U-shaped track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4; // Changed from 3 to 4 as requested
                const letterHeight = playableMaxY - playableMinY + 1;
                const letterWidth = playableMaxX - playableMinX + 1;

                // Left vertical arm
                unblockRectangle(playableMinX, playableMinY, pathWidth, letterHeight);

                // Right vertical arm
                unblockRectangle(playableMaxX - pathWidth + 1, playableMinY, pathWidth, letterHeight);

                // Bottom connecting curve/bar
                unblockRectangle(playableMinX, playableMaxY - pathWidth + 1, letterWidth, pathWidth);

                // Define Start and Finish Line coordinates for U-Track
                // Start line: Horizontal, at the top-left portion of the U
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX + pathWidth -1, y1: playableMinY, type: 'horizontal' };
                // Finish line: Horizontal, at the top-right portion of the U
                const finishLine = { x0: playableMaxX - pathWidth + 1, y0: playableMinY, x1: playableMaxX, y1: playableMinY, type: 'horizontal' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'm-track',
            name: 'M-Track',
            description: 'Conquer the peaks and valleys of this M-shaped course (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4; // Increased thickness for better playability and guaranteed connection
                const letterWidth = playableMaxX - playableMinX + 1;
                const letterHeight = playableMaxY - playableMinY + 1;

                // Relative coordinates for M points (scaled to playable area)
                const p1x = playableMinX;
                const p1y = playableMaxY; // Bottom-left
                const p2x = Math.floor(playableMinX + letterWidth * 0.25);
                const p2y = playableMinY; // Top-left peak
                const p3x = Math.floor(playableMinX + letterWidth * 0.5);
                const p3y = Math.floor(playableMinY + letterHeight * 0.5) + Math.floor(pathWidth / 2); // Middle valley
                const p4x = Math.floor(playableMinX + letterWidth * 0.75);
                const p4y = playableMinY; // Top-right peak
                const p5x = playableMaxX;
                const p5y = playableMaxY; // Bottom-right

                // Unblock segments of the 'M'
                unblockDiagonal(p1x, p1y, p2x, p2y, pathWidth); // Bottom-left to top-left peak
                unblockDiagonal(p2x, p2y, p3x, p3y, pathWidth); // Top-left peak to middle valley
                unblockDiagonal(p3x, p3y, p4x, p4y, pathWidth); // Middle valley to top-right peak
                unblockDiagonal(p4x, p4y, p5x, p5y, pathWidth); // Top-right peak to bottom-right

                // Define Start and Finish Line coordinates for M-Track (both horizontal at the bottom arms)
                const startLine = { x0: p1x, y0: p1y, x1: p1x + pathWidth -1, y1: p1y, type: 'horizontal' }; // Starts bottom-left horizontal
                const finishLine = { x0: p5x - pathWidth + 1, y0: p5y, x1: p5x, y1: p5y, type: 'horizontal' }; // Finishes bottom-right horizontal
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 's-track',
            name: 'S-Track',
            description: 'Test your turning skills on the classic S-bend track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2); // Top/Bottom
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows); // Left/Right

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4; // Changed from 3 to 4 as requested

                // Calculate center points for S-curve
                const midX = Math.floor(playableMinX + (playableMaxX - playableMinX) / 2);
                const midY = Math.floor(playableMinY + (playableMaxY - playableMinY) / 2);

                // S-shape unblocking
                // Part 1: Top-left vertical segment
                unblockRectangle(playableMinX, playableMinY, pathWidth, midY - playableMinY + pathWidth / 2);

                // Part 2: Diagonal from top-left area to bottom-right area
                // This will connect the top-left vertical segment to the bottom-right vertical segment
                // A simplified S curve can be achieved by two diagonal segments.
                unblockDiagonal(playableMinX, midY, playableMaxX - pathWidth + 1, playableMaxY - pathWidth + 1, pathWidth);

                // Part 3: Bottom-right vertical segment
                unblockRectangle(playableMaxX - pathWidth + 1, midY - pathWidth / 2, pathWidth, playableMaxY - midY + pathWidth / 2 + 1);


                // Define Start and Finish Line coordinates for S-Track (both vertical)
                // Start line: Vertical, at the very beginning of the left arm
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMinY + pathWidth, type: 'vertical' };
                // Finish line: Vertical, at the very end of the right arm
                const finishLine = { x0: playableMaxX, y0: playableMaxY - pathWidth, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        }
    ];


    // --- Game State and Setup Variables ---
    let stagedPlayers = []; // Players selected on the setup screen
    let selectedTrackId = trackDefinitions[0].id; // Default selected track is the first one (Simple Sprint now)

    // Game state variables - entirely local now
    let gameState = {
      players: [], // Will be populated from initGame based on stagedPlayers
      currentPlayerIndex: 0,
      gameStatus: 'playing', // 'playing', 'finished' (removed 'finishing_round')
      finishedPlayers: [], // Stores indices of players who crossed finish line
      winnerIndex: null, // Stores index of the winning player
      turnCount: 0 // Track overall turns
    };

    let blockedCells = new Set(); // Set to store coordinates of all blocked cells (walls and boundaries)
    let flashing = false; // Flag to control crash animation
    let animationFrameId = null; // To store the requestAnimationFrame ID

    // --- Custom Message Box Functions ---
    const messageBoxOverlay = document.getElementById('messageBoxOverlay');
    const messageBoxText = document.getElementById('messageBoxText');
    const messageBoxContent = document.getElementById('messageBoxContent');
    let messageBoxCallback = null; // Store callback for when OK is pressed

    /**
     * Displays a custom message box.
     * @param {string} message - The message to display.
     * @param {string} type - 'success' or 'error' (for future styling differentiation if needed).
     * @param {function} callback - Optional function to call when 'OK' is clicked.
     */
    function showMessageBox(message, type = "info", callback = null) {
      if (!messageBoxOverlay || !messageBoxText || !messageBoxContent) {
          console.error("Message box elements not found in DOM yet. Cannot display message:", message);
          return;
      }
      messageBoxText.innerText = message;
      messageBoxOverlay.classList.remove('hidden');
      messageBoxCallback = callback; // Store the callback
      // Optional: Add type-based styling to messageBoxContent
      if (type === 'error') {
        messageBoxContent.classList.remove('border-blue-500');
        messageBoxContent.style.border = '2px solid #EF4444'; // Red border for errors
      } else if (type === 'success') {
        messageBoxContent.classList.remove('border-red-500');
        messageBoxContent.style.border = '2px solid #10B981'; // Green border for success
      } else {
        messageBoxContent.style.border = 'none'; // Default
      }
    }

    /**
     * Hides the custom message box and executes any pending callback.
     */
    function hideMessageBox() {
      if (!messageBoxOverlay) return;
      messageBoxOverlay.classList.add('hidden');
      if (messageBoxCallback) {
        messageBoxCallback(); // Execute callback if it exists
        messageBoxCallback = null; // Clear callback
      }
    }

    // --- Utility Functions ---

    /**
     * Generates a unique string key for a given grid cell.
     * @param {number} x - X-coordinate of the cell.
     * @param {number} y - Y-coordinate of the cell.
     * @returns {string} Unique key for the cell.
     */
    function cellKey(x, y) {
      return `${x},${y}`;
    }

    /**
     * Adds a rectangular block of cells to the blockedCells set.
     * @param {number} startX - Starting X-coordinate of the block.
     * @param {number} startY - Starting Y-coordinate of the block.
     * @param {number} width - Width of the rectangle (grid units).
     * @param {number} height - Height of the rectangle (grid units).
     */
    function addBlock(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          blockedCells.add(cellKey(x, y));
        }
      }
    }

    /**
     * Sets the disabled state of all game control buttons.
     * @param {boolean} enableVelocity - True to enable velocity change buttons, false to disable.
     * @param {boolean} enableMove - True to enable the move button, false to disable.
     */
    function setControlButtonsState(enableVelocity, enableMove) {
        document.getElementById('vxMinus').disabled = !enableVelocity;
        document.getElementById('vxPlus').disabled = !enableVelocity;
        document.getElementById('vyMinus').disabled = !enableVelocity;
        document.getElementById('vyPlus').disabled = !enableVelocity;
        document.getElementById('moveButton').disabled = !enableMove;
        document.getElementById('resetButton').disabled = false; // Always enabled
    }

    // --- Drawing Functions ---

    /**
     * Draws the grid lines on the canvas.
     */
    function drawGrid() {
      ctx.strokeStyle = "#E5E7EB";
      ctx.lineWidth = 1;
      for (let x = 0; x <= cols; x++) {
        const px = x * gridSize;
        ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke();
      }
      for (let y = 0; y <= rows; y++) {
        const py = y * gridSize;
        ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke();
      }
    }

    /**
     * Defines and draws the track area, including boundaries, start/finish lines, and wall hurdles.
     */
    function drawTrackArea() {
      // The track layout is now determined by the selectedTrackId
      const selectedTrack = trackDefinitions.find(t => t.id === selectedTrackId);
      if (selectedTrack) {
          selectedTrack.drawLayout(); // This will populate `blockedCells` and draw specific lines
      } else {
          // Fallback if somehow no track is selected or found (shouldn't happen with default)
          console.error("No track selected or found. Drawing default layout.");
          trackDefinitions[0].drawLayout();
      }

      // Draw all blocked cells (walls)
      ctx.fillStyle = "#4B5563"; // Dark gray for walls (Tailwind gray-700)
      blockedCells.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
      });

      // Note: Start/Finish lines and text are now drawn within each track's drawLayout function.
    }

    /**
     * Shows a preview of the next potential move for the current player's car.
     */
    function showNextMovePreview() {
      const currentPlayer = gameState.players[gameState.currentPlayerIndex];
      if (!currentPlayer || currentPlayer.hasFinished || gameState.gameStatus === 'finished') return;

      const nx = currentPlayer.x + currentPlayer.vx;
      const ny = currentPlayer.y + currentPlayer.vy;
      ctx.fillStyle = "rgba(59, 130, 246, 0.4)";
      ctx.beginPath();
      ctx.arc(nx * gridSize, ny * gridSize, 7, 0, 2 * Math.PI);
      ctx.fill();
    }

    /**
     * Updates the velocity display text for the current player's car.
     */
    function updateVelocityDisplay() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (currentPlayer) {
            document.getElementById("velocity").innerText = `Current Player's Velocity: (${currentPlayer.vx}, ${currentPlayer.vy})`;
        } else {
            document.getElementById("velocity").innerText = `Current Player's Velocity: (0, 0)`;
        }
    }


    /**
     * Draws all players and their path histories, incorporating animation.
     * @param {number} timestamp - The current timestamp from requestAnimationFrame.
     */
    function drawPlayers(timestamp) {
        if (!gameState.players || gameState.players.length === 0) return;

        gameState.players.forEach((p, index) => {
            let currentDrawX = p.x;
            let currentDrawY = p.y;

            // If player is animating, calculate interpolated position
            if (p.isAnimating && p.animationStartTime !== null) {
                const elapsed = timestamp - p.animationStartTime;
                const progress = Math.min(elapsed / p.animationDuration, 1); // 0 to 1

                currentDrawX = p.animationStartPos[0] + (p.animationEndPos[0] - p.animationStartPos[0]) * progress;
                currentDrawY = p.animationStartPos[1] + (p.animationEndPos[1] - p.animationStartPos[1]) * progress;

                // If animation is complete, update player's actual position
                if (progress === 1) {
                    p.isAnimating = false;
                    p.animationStartTime = null;
                    p.x = p.animationEndPos[0];
                    p.y = p.animationEndPos[1];
                    // Only add to path if it's a *successful* move and not a crash-back
                    // The path is already updated for crashes *before* animation
                    if (!p.isCrashAnimation) { // Use a flag to differentiate animation types
                        p.path.push([p.x, p.y]);
                    }
                    // Once animation is done, proceed with turn end logic
                    if (p.animationCompletionCallback) {
                        p.animationCompletionCallback();
                        p.animationCompletionCallback = null; // Clear callback
                        p.isCrashAnimation = false; // Reset crash animation flag
                    }
                }
            }

            ctx.strokeStyle = p.color;
            ctx.lineWidth = 2;

            // Draw path history up to the current animated point
            ctx.beginPath();
            if (p.path && p.path.length > 0) {
                // Draw up to the last confirmed position
                p.path.forEach(([x, y], i) => {
                    const px = x * gridSize;
                    const py = y * gridSize;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
            }
            // If animating, draw line segment to current animated position
            if (p.isAnimating) {
                ctx.lineTo(currentDrawX * gridSize, currentDrawY * gridSize);
            }
            ctx.stroke();


            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(currentDrawX * gridSize, currentDrawY * gridSize, 5, 0, 2 * Math.PI); // Player dot at interpolated position
            ctx.fill();

            // Highlight current player's car
            if (index === gameState.currentPlayerIndex && gameState.gameStatus === 'playing') {
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(currentDrawX * gridSize, currentDrawY * gridSize, 8, 0, 2 * Math.PI);
                ctx.stroke();
            }
        });

        // Request next frame if any player is still animating
        if (gameState.players.some(p => p.isAnimating)) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        } else {
            animationFrameId = null; // No more animations, stop loop
        }
    }

    /**
     * The main game animation loop.
     * @param {DOMHighResTimeStamp} timestamp - The current time provided by requestAnimationFrame.
     */
    function animateGameLoop(timestamp) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas
        drawGrid();
        drawTrackArea();
        drawPlayers(timestamp); // Pass timestamp to drawPlayers for animation
        showNextMovePreview();
        updateVelocityDisplay();
    }

    /**
     * Main render function to trigger a screen update.
     * This now initiates the animation loop if it's not already running.
     */
    function render() {
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }


    // --- UI Update Functions ---

    /**
     * Updates UI elements based on the current game state.
     */
    function updateGameUI() {
        document.getElementById('gameStatusInfo').innerText = `Status: ${gameState.gameStatus.replace(/_/g, ' ')}`;

        // Update player list
        const playersContainer = document.getElementById('playersContainer');
        playersContainer.innerHTML = ''; // Clear existing list
        gameState.players.forEach((p, index) => {
            const li = document.createElement('li');
            li.className = 'flex items-center';
            const colorBox = document.createElement('span');
            colorBox.className = 'player-indicator';
            colorBox.style.backgroundColor = p.color;
            li.appendChild(colorBox);
            li.appendChild(document.createTextNode(`Player ${index + 1}`));
            if (index === gameState.currentPlayerIndex) {
                li.classList.add('font-bold', 'text-purple-700'); // Highlight current player
            }
            if (p.hasFinished) {
                li.classList.add('line-through', 'opacity-70');
            }
            playersContainer.appendChild(li);
        });

        // Update current turn info and button states
        if (gameState.players.length > 0) {
            document.getElementById('currentTurnInfo').innerText = `Player ${gameState.currentPlayerIndex + 1}'s Turn!`;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            // Controls enabled only if game is playing and no animation is active
            const canControl = (gameState.gameStatus === 'playing' && !currentPlayer.isAnimating);

            // Velocity buttons disabled if already changed this turn, or if controls are generally disabled
            setControlButtonsState(canControl && !currentPlayer.hasChangedVelocityThisTurn, canControl);
        } else {
            document.getElementById('currentTurnInfo').innerText = "Game not initialized.";
            setControlButtonsState(false, false); // Disable all if no players/game not started
        }

        // Show winner if game finished
        if (gameState.gameStatus === 'finished' && gameState.winnerIndex !== null) {
            // Message box handled directly by determineWinner()
            setControlButtonsState(false, false); // Disable controls after game ends
        }
    }


    // --- Game Logic Functions ---

    /**
     * Changes the current player's X-velocity.
     * @param {number} delta - Amount to change velocity by (typically -1 or 1).
     */
    function changeVX(delta) {
        if (flashing || gameState.gameStatus !== 'playing') return; // Only allow changes if playing

        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        // Check if velocity has already been changed this turn
        if (currentPlayer.hasChangedVelocityThisTurn) {
            showMessageBox("You can only change velocity once per turn (either X or Y). Click 'Move' to proceed.", "info");
            return;
        }

        currentPlayer.vx += delta;
        currentPlayer.hasChangedVelocityThisTurn = true;

        updateGameUI(); // Update UI to reflect disabled velocity buttons
        render(); // Re-render with updated velocity preview
    }

    /**
     * Changes the current player's Y-velocity.
     * @param {number} delta - Amount to change velocity by (typically -1 or 1).
     */
    function changeVY(delta) {
        if (flashing || gameState.gameStatus !== 'playing') return; // Only allow changes if playing

        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        // Check if velocity has already been changed this turn
        if (currentPlayer.hasChangedVelocityThisTurn) {
            showMessageBox("You can only change velocity once per turn (either X or Y). Click 'Move' to proceed.", "info");
            return;
        }

        currentPlayer.vy += delta;
        currentPlayer.hasChangedVelocityThisTurn = true;

        updateGameUI(); // Update UI to reflect disabled velocity buttons
        render(); // Re-render with updated velocity preview
    }

    /**
     * Advances to the next player's turn. This function is for regular turn progression.
     */
    async function advancePlayerTurn() {
        if (gameState.gameStatus === 'finished') return; // Do not advance turn if game is over

        let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
        gameState.turnCount++; // Increment total turns

        // Reset hasChangedVelocityThisTurn for the new current player
        if (gameState.players[nextPlayerIndex]) {
            gameState.players[nextPlayerIndex].hasChangedVelocityThisTurn = false;
        }

        // Skip players who have already finished
        let attempts = 0;
        while (gameState.players[nextPlayerIndex].hasFinished && attempts < gameState.players.length) {
            nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
            attempts++;
        }
        // If all players have finished, this loop will return to the current player, and the game will likely already be finished
        if (attempts === gameState.players.length && gameState.players[nextPlayerIndex].hasFinished) {
            // This case means all players have finished their turns or crossed the line.
            // The `determineWinner` should have already been called if someone finished.
            return;
        }

        gameState.currentPlayerIndex = nextPlayerIndex;
        updateGameUI();
        render(); // Initial render for the new player's turn (before they move)
    }


    /**
     * Handles the end of a player's turn, including post-crash logic.
     * This is called AFTER animation completes (or immediately for instant actions).
     * @param {boolean} isCrash - True if the turn ended due to a crash.
     */
    async function handleTurnEnd(isCrash = false) {
        if (gameState.gameStatus === 'finished') return; // Do not proceed if game is already over

        // If single player and crashed, their turn effectively restarts immediately
        if (isCrash && gameState.players.length === 1) {
            // Velocity is already reset by crash logic.
            // Reset hasChangedVelocityThisTurn for current player
            gameState.players[gameState.currentPlayerIndex].hasChangedVelocityThisTurn = false;
            updateGameUI(); // This will re-enable buttons for the current player
            render();
        } else {
            // For multiplayer crashes or any successful move, advance to next player
            await advancePlayerTurn();
        }
    }


    /**
     * Attempts to move the current player based on current velocity.
     * Handles collisions and win condition.
     */
    async function movePlayer() {
        if (flashing || gameState.gameStatus === 'finished') return;

        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        // Disable controls during calculation/animation
        setControlButtonsState(false, false);

        if (currentPlayer.hasFinished) { // If a player has already finished, they cannot move again
            // This check is mainly for 'finishing_round' logic which is now removed.
            // With immediate game over, this block might be less critical.
            showMessageBox("You have already finished the race! Game is ending.", "info", async () => {
                // If game is finished, determineWinner should have been called.
                // Just hide the box.
            });
            return;
        }

        // Velocity must not be (0,0) after initial setup turns.
        // During initial setup (turnCount < numPlayers), players can start from (0,0).
        // After that, (0,0) velocity should only be if they crash.
        if (gameState.turnCount >= gameState.players.length && currentPlayer.vx === 0 && currentPlayer.vy === 0) {
            showMessageBox("Velocity (0,0) is not allowed after initial setup. Change your velocity before moving.", "error", () => {
                // If they need to change velocity, re-enable controls for the current player's turn
                currentPlayer.hasChangedVelocityThisTurn = false; // Allow velocity change after 0,0 error
                setControlButtonsState(true, true);
                render();
            });
            return;
        }

        // Calculate next potential position based on current velocity
        const nextPotentialX = currentPlayer.x + currentPlayer.vx;
        const nextPotentialY = currentPlayer.y + currentPlayer.vy;

        let crashOccurred = false;
        let crashMessage = "";
        let finalPlayerX = nextPotentialX;
        let finalPlayerY = nextPotentialY;

        // --- Prioritize Win Condition ---
        // Get the actual startLine and finishLine from the currently selected track
        const currentTrack = trackDefinitions.find(t => t.id === selectedTrackId);
        // It's important to call drawLayout() here to get the up-to-date line definitions
        // as they might be dynamically calculated or depend on canvas size.
        const { finishLine } = currentTrack.drawLayout();

        let crossedFinishLine = false;
        if (finishLine.type === 'horizontal') {
            const minX = Math.min(finishLine.x0, finishLine.x1);
            const maxX = Math.max(finishLine.x0, finishLine.x1);
            const yThreshold = finishLine.y0;

            // Determine crossing direction based on line's Y position relative to canvas center
            if (yThreshold < (rows / 2)) { // This is a top horizontal line (cross by decreasing Y)
                crossedFinishLine = (nextPotentialY <= yThreshold) && (nextPotentialX >= minX && nextPotentialX <= maxX);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = yThreshold - nextPotentialY; // Positive if currentY is smaller than yThreshold
                }
            } else { // This is a bottom horizontal line (cross by increasing Y)
                crossedFinishLine = (nextPotentialY >= yThreshold) && (nextPotentialX >= minX && nextPotentialX <= maxX);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = nextPotentialY - yThreshold; // Positive if currentY is larger than yThreshold
                }
            }
        } else { // vertical finish line
            const minY = Math.min(finishLine.y0, finishLine.y1);
            const maxY = Math.max(finishLine.y0, finishLine.y1);
            const xThreshold = finishLine.x0;

            // Determine crossing direction based on line's X position relative to canvas center
            if (xThreshold < (cols / 2)) { // This is a left vertical line (cross by decreasing X)
                crossedFinishLine = (nextPotentialX <= xThreshold) && (nextPotentialY >= minY && nextPotentialY <= maxY);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = xThreshold - nextPotentialX; // Positive if currentX is smaller than xThreshold
                }
            } else { // This is a right vertical line (cross by increasing X)
                crossedFinishLine = (nextPotentialX >= xThreshold) && (nextPotentialY >= minY && nextPotentialY <= maxY);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = nextPotentialX - xThreshold; // Positive if currentX is larger than xThreshold
                }
            }
        }


        if (crossedFinishLine) {
            // Player has crossed the finish line!
            currentPlayer.hasFinished = true;
            gameState.gameStatus = 'finished'; // Game is immediately over
            gameState.finishedPlayers.push(gameState.currentPlayerIndex);

            // Set final position to the intended next position, even if it's "off-track"
            finalPlayerX = nextPotentialX;
            finalPlayerY = nextPotentialY;

            // Animate to the final position beyond the finish line
            currentPlayer.isAnimating = true;
            currentPlayer.animationStartTime = performance.now();
            currentPlayer.animationDuration = 300;
            currentPlayer.animationStartPos = [currentPlayer.x, currentPlayer.y];
            currentPlayer.animationEndPos = [finalPlayerX, finalPlayerY];
            currentPlayer.isCrashAnimation = false; // It's a win, not a crash animation

            currentPlayer.animationCompletionCallback = async () => {
                currentPlayer.path.push([currentPlayer.x, currentPlayer.y]); // Add final position to path
                await determineWinner(); // Declare winner immediately
            };
        } else {
            // --- Player Collision Check (prevents movement, keeps turn) ---
            const otherPlayers = gameState.players.filter((p, idx) => idx !== gameState.currentPlayerIndex && !p.hasFinished);
            if (otherPlayers.some(p => p.x === nextPotentialX && p.y === nextPotentialY)) {
                showMessageBox(`WARNING! Player ${gameState.currentPlayerIndex + 1} cannot move to (${nextPotentialX}, ${nextPotentialY}) because another player is there. Please adjust your velocity.`, "info", () => {
                    currentPlayer.hasChangedVelocityThisTurn = false; // Allow them to change velocity again
                    setControlButtonsState(true, true); // Re-enable all controls for the current player
                    render(); // Re-render to update UI (buttons, preview, etc.)
                });
                return; // Prevent further move logic, current player's turn continues
            }

            // --- Wall/Boundary Collision Check (causes crash, advances turn) ---
            if (blockedCells.has(cellKey(nextPotentialX, nextPotentialY))) {
                crashOccurred = true;
                crashMessage = "CRASH! You hit a wall or went out of bounds. Velocity reset. Your position reverted to last valid spot.";

                // Crash Position Resolution (this part is generic and should work fine)
                const attemptedDx = currentPlayer.vx;
                const attemptedDy = currentPlayer.vy;

                // Try moving only in X direction
                const movedXOnlyBlocked = blockedCells.has(cellKey(currentPlayer.x + attemptedDx, currentPlayer.y));
                // Try moving only in Y direction
                const movedYOnlyBlocked = blockedCells.has(cellKey(currentPlayer.x, currentPlayer.y + attemptedDy));

                if (!movedXOnlyBlocked && !movedYOnlyBlocked) {
                    finalPlayerX = currentPlayer.lastValidX;
                    finalPlayerY = currentPlayer.lastValidY;
                } else if (movedXOnlyBlocked && !movedYOnlyBlocked) {
                    finalPlayerX = currentPlayer.x;
                    finalPlayerY = currentPlayer.y + attemptedDy;
                } else if (!movedXOnlyBlocked && movedYOnlyBlocked) {
                    finalPlayerX = currentPlayer.x + attemptedDx;
                    finalPlayerY = currentPlayer.y;
                } else {
                    finalPlayerX = currentPlayer.lastValidX;
                    finalPlayerY = currentPlayer.lastValidY;
                }

                // Final check: if the resolved position is still blocked, definitely revert.
                if (blockedCells.has(cellKey(finalPlayerX, finalPlayerY))) {
                    finalPlayerX = currentPlayer.lastValidX;
                    finalPlayerY = currentPlayer.lastValidY;
                }

            }

            // Animate for crash or normal move (within track)
            currentPlayer.isAnimating = true;
            currentPlayer.animationStartTime = performance.now();
            currentPlayer.animationDuration = 300;
            currentPlayer.animationStartPos = [currentPlayer.x, currentPlayer.y];

            if (crashOccurred) {
                currentPlayer.vx = 0; // Reset velocity on crash
                currentPlayer.vy = 0;
                currentPlayer.animationEndPos = [finalPlayerX, finalPlayerY];
                currentPlayer.isCrashAnimation = true;
                currentPlayer.animationCompletionCallback = async () => {
                    await flashCrash(nextPotentialX, nextPotentialY); // Flash at attempted crash location
                    showMessageBox(crashMessage, "error", async () => {
                        updateGameUI(); // Re-render to show updated velocity/position
                        await handleTurnEnd(true); // Indicate crash
                    });
                };
            } else {
                currentPlayer.animationEndPos = [nextPotentialX, nextPotentialY];
                currentPlayer.isCrashAnimation = false;
                currentPlayer.animationCompletionCallback = async () => {
                    currentPlayer.path.push([currentPlayer.x, currentPlayer.y]); // Add new position to path
                    currentPlayer.lastValidX = currentPlayer.x; // Update last valid for next turn
                    currentPlayer.lastValidY = currentPlayer.y;
                    await handleTurnEnd(false); // Normal turn end
                };
            }
        }

        // Start the animation loop if not already running
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }

    /**
     * Determines the winner when the game concludes.
     */
    async function determineWinner() {
        let winningPlayerIndex = null;
        let bestDistance = -Infinity; // Always looking for the largest positive distance

        const finishedRacers = gameState.players.filter(p => p.hasFinished);

        if (finishedRacers.length > 0) {
            for (let i = 0; i < finishedRacers.length; i++) {
                const p = finishedRacers[i];
                if (p.distancePastFinishLine > bestDistance) {
                    bestDistance = p.distancePastFinishLine;
                    winningPlayerIndex = gameState.players.indexOf(p); // Get original index
                }
            }
        } else {
            winningPlayerIndex = null; // No one finished
        }

        gameState.gameStatus = 'finished';
        gameState.winnerIndex = winningPlayerIndex;
        updateGameUI(); // Final UI update for winner
        render(); // Final render

        if (winningPlayerIndex !== null) {
            showMessageBox(`Game Over! The winner is Player ${winningPlayerIndex + 1}!`, "success", () => resetGame());
        } else {
            showMessageBox("Game Over! No one crossed the finish line. Try again!", "info", () => resetGame());
        }
    }

    /**
     * Animates a crash visual by flashing the crash location.
     * @param {number} x - X-coordinate of the crash.
     * @param {number} y - Y-coordinate of the crash.
     */
    async function flashCrash(x, y) {
      flashing = true;
      let count = 0;
      const interval = setInterval(() => {
        ctx.fillStyle = count % 2 === 0 ? "#EF4444" : "rgba(0,0,0,0)";
        ctx.beginPath();
        ctx.arc(x * gridSize, y * gridSize, 10, 0, 2 * Math.PI);
        ctx.fill();
        count++;
        if (count >= 6) {
          clearInterval(interval);
          flashing = false;
          render(); // Re-render to clear any lingering flash artifacts
        }
      }, 100);
      return new Promise(resolve => setTimeout(() => resolve(), 600)); // Wait for flash to complete
    }

    /**
     * Resets the entire game to its initial state (back to setup screen).
     */
    function resetGame() {
        // Clear game screen and show setup screen
        document.getElementById('gameScreen').classList.add('hidden');
        document.getElementById('gameScreen').classList.remove('flex'); // Remove flex when hidden
        document.getElementById('setupScreen').classList.remove('hidden');

        // Reset staged players and re-render setup UI
        stagedPlayers = [];
        selectedTrackId = trackDefinitions[0].id; // Reset to default track (Simple Sprint)
        renderSetupScreen();

        // Optional: Show a message that game was reset
        showMessageBox("Game has been reset! Choose players and a track to start a new race.", "info");
    }

    // --- Game Initialization & Setup Screen Logic ---
    /**
     * Initializes the game with the selected players and track.
     * This is called when 'Start Race' is clicked from the setup screen.
     */
    function initGame() {
        // Cancel any ongoing animations before resetting
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        // Reset game state for a new game
        gameState.players = [];
        gameState.currentPlayerIndex = 0;
        gameState.gameStatus = 'playing';
        gameState.finishedPlayers = [];
        // Removed maxTurnsInRound as it's no longer needed for immediate game over
        gameState.winnerIndex = null;
        gameState.turnCount = 0;

        // Get track layout details (including start/finish lines)
        const selectedTrack = trackDefinitions.find(t => t.id === selectedTrackId);
        let trackLines = { startLine: {}, finishLine: {} }; // Default empty
        if (selectedTrack) {
            trackLines = selectedTrack.drawLayout(); // This populates blockedCells AND returns line info
        } else {
            console.error("Selected track not found:", selectedTrackId);
            trackDefinitions[0].drawLayout(); // Fallback to default
        }

        const startLine = trackLines.startLine; // Get startLine info

        // Populate players from staged players, aligning with the start line
        stagedPlayers.forEach((p, i) => {
            let playerStartX, playerStartY;
            const numPlayers = stagedPlayers.length;
            const offsetIntoTrack = 1; // 1 grid unit inside the path for better visual placement

            // For vertical lines, distribute along Y. For horizontal, distribute along X.
            if (startLine.type === 'horizontal') {
                playerStartY = startLine.y0 + offsetIntoTrack;
                // Distribute players evenly along the X-segment of the start line
                // Adjust for multiple players on a horizontal line to space them out
                const segmentLength = startLine.x1 - startLine.x0;
                playerStartX = startLine.x0 + ((i + 0.5) / numPlayers) * segmentLength;
            } else { // 'vertical'
                playerStartX = startLine.x0 + offsetIntoTrack;
                // Distribute players evenly along the Y-segment of the start line
                // Adjust for multiple players on a vertical line to space them out
                const segmentLength = startLine.y1 - startLine.y0;
                playerStartY = startLine.y0 + ((i + 0.5) / numPlayers) * segmentLength;
            }

            gameState.players.push({
                id: p.id,
                x: Math.round(playerStartX), // Round to nearest integer grid coordinate
                y: Math.round(playerStartY), // Round to nearest integer grid coordinate
                vx: 0,
                vy: 0,
                path: [[Math.round(playerStartX), Math.round(playerStartY)]], // Store path points as grid coords
                color: p.color,
                hasFinished: false,
                distancePastFinishLine: 0,
                lastValidX: Math.round(playerStartX), // Last safe position before attempted move
                lastValidY: Math.round(playerStartY),
                // Animation properties
                isAnimating: false,
                animationStartTime: null,
                animationDuration: 300, // Default duration for move animation
                animationStartPos: [Math.round(playerStartX), Math.round(playerStartY)],
                animationEndPos: [Math.round(playerStartX), Math.round(playerStartY)],
                animationCompletionCallback: null,
                isCrashAnimation: false, // New flag for crash animations
                hasChangedVelocityThisTurn: false // Re-added flag for velocity change restriction
            });
        });

        updateGameUI(); // Update UI with new players and turn info
        // Start the game loop for the initial render
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }

    /**
     * Renders the setup screen with current players and track options.
     */
    function renderSetupScreen() {
        // Update Player Count
        document.getElementById('playerCount').innerText = stagedPlayers.length;
        document.getElementById('addPlayerButton').disabled = stagedPlayers.length >= 4;
        document.getElementById('removePlayerButton').disabled = stagedPlayers.length === 0;

        // Update Staged Players List
        const stagedPlayersContainer = document.getElementById('stagedPlayersContainer');
        stagedPlayersContainer.innerHTML = '';
        if (stagedPlayers.length === 0) {
            stagedPlayersContainer.innerHTML = '<p class="text-gray-500">No players added yet.</p>';
        } else {
            stagedPlayers.forEach((p, index) => {
                const li = document.createElement('div');
                li.className = 'flex items-center text-lg font-medium';
                const colorBox = document.createElement('span');
                colorBox.className = 'player-indicator';
                colorBox.style.backgroundColor = p.color;
                li.appendChild(colorBox);
                li.appendChild(document.createTextNode(`Player ${index + 1}`));
                stagedPlayersContainer.appendChild(li);
            });
        }

        // Render Track Selection
        const trackSelectionContainer = document.getElementById('trackSelectionContainer');
        trackSelectionContainer.innerHTML = ''; // Clear previous options
        trackDefinitions.forEach(track => {
            const trackDiv = document.createElement('div');
            trackDiv.id = `track-${track.id}`;
            trackDiv.className = `track-selection-item p-4 rounded-lg cursor-pointer hover:bg-gray-100 transition duration-150 ease-in-out ${selectedTrackId === track.id ? 'selected' : ''}`;
            trackDiv.onclick = () => selectTrack(track.id);
            trackDiv.innerHTML = `
                <h4 class="font-bold text-gray-800 text-lg mb-1">${track.name}</h4>
                <p class="text-sm text-gray-600">${track.description}</p>
            `;
            trackSelectionContainer.appendChild(trackDiv);
        });
    }

    /**
     * Adds a player to the stagedPlayers array.
     */
    function addPlayer() {
        if (stagedPlayers.length < 4) {
            const newPlayerId = `player${stagedPlayers.length + 1}`;
            const newPlayerColor = playerColors[stagedPlayers.length % playerColors.length];
            stagedPlayers.push({
                id: newPlayerId,
                color: newPlayerColor
            });
            renderSetupScreen();
        } else {
            showMessageBox("Maximum of 4 players allowed.", "info");
        }
    }

    /**
     * Removes the last player from the stagedPlayers array.
     */
    function removePlayer() {
        if (stagedPlayers.length > 0) {
            stagedPlayers.pop();
            renderSetupScreen();
        } else {
            showMessageBox("No players to remove.", "info");
        }
    }

    /**
     * Sets the selected track for the game.
     * @param {string} trackId - The ID of the selected track.
     */
    function selectTrack(trackId) {
        selectedTrackId = trackId;
        renderSetupScreen(); // Re-render to update selection highlight
    }

    /**
     * Starts the race, transitioning from setup to game screen.
     */
    function startGame() {
        if (stagedPlayers.length === 0) {
            showMessageBox("Please add at least one player to start the game.", "error");
            return;
        }
        if (!selectedTrackId) {
            showMessageBox("Please select a track before starting the game.", "error");
            return;
        }

        document.getElementById('setupScreen').classList.add('hidden');
        document.getElementById('gameScreen').classList.remove('hidden');
        document.getElementById('gameScreen').classList.add('flex'); // Ensure it's flex for centering

        initGame(); // Initialize the game with selected players and track
    }

    // --- Initial setup on window load ---
    window.onload = function() {
        // Initialize staged players and render the setup screen
        addPlayer(); // Add Player 1 by default
        selectTrack(trackDefinitions[0].id); // Select first track by default (Simple Sprint)
        renderSetupScreen();
    };

    // Expose functions to global scope for HTML onclick attributes to work
    window.addPlayer = addPlayer;
    window.removePlayer = removePlayer;
    window.selectTrack = selectTrack;
    window.startGame = startGame;
    window.changeVX = changeVX;
    window.changeVY = changeVY;
    window.movePlayer = movePlayer;
    window.resetGame = resetGame;
    window.hideMessageBox = hideMessageBox;
    window.showMessageBox = showMessageBox;
  </script>
</body>
</html>
