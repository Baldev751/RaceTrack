<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Local Multiplayer Racetrack Challenge</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom font for a more modern look */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    canvas {
      background-color: white;
      display: block;
      margin: 20px 0;
      border: 2px solid #333;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    /* Styles for the custom message box */
    .message-box-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .message-box-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 400px;
      width: 90%;
      transform: scale(0.95);
      opacity: 0;
      animation: fadeInScale 0.2s forwards;
    }
    @keyframes fadeInScale {
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
    /* Disabled button styling */
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    button:disabled:hover {
        background-color: #4F46E5;
    }
    .player-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      vertical-align: middle;
    }
    .track-selection-item {
        border: 2px solid transparent;
        transition: all 0.2s ease-in-out;
    }
    .track-selection-item.selected {
        border-color: #4F46E5;
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.5);
        transform: scale(1.02);
    }
    /* Movement controls styling */
    .movement-grid-button {
        border: 1px solid #ccc;
        background-color: #e2e8f0;
        color: #4a5568;
        cursor: pointer;
    }
    .movement-grid-button:hover:enabled {
        background-color: #93c5fd;
    }
    .movement-grid-button.selected-move {
        background-color: #3b82f6;
        color: white;
        border-color: #1d4ed8;
    }
    .movement-grid-button:disabled {
        background-color: #cbd5e0;
        color: #a0aec0;
        cursor: not-allowed;
    }
    #movementControl.pointer-events-none {
        pointer-events: none;
    }
    #movementControl.opacity-50 {
        opacity: 0.5;
    }
    /* Game container layout */
    .game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      align-items: flex-start;
    }
    .track-container {
      flex: 0 0 auto;
    }
    .controls-container {
      flex: 0 0 300px;
      background: rgb(255, 255, 255);
       margin-top: 20px;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .player-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    .player-item {
      display: flex;
      align-items: center;
      padding: 5px 10px;
      border-radius: 4px;
      background: #f3f4f6;
    }
    .player-item.current {
      font-weight: bold;
      background: #e0e7ff;
    }
    .player-item.finished {
      text-decoration: line-through;
      opacity: 0.7;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-[#B4D44B] to-green-200 min-h-screen py-8">


  <!-- Setup Screen -->
  <div id="setupScreen" class="bg-white p-8 rounded-lg shadow-xl w-11/12 max-w-2xl mx-auto flex flex-col items-center relative">
    <!-- Show Rules Button (top right) -->
    <button onclick="showRules()" class="absolute top-4 right-4 px-6 py-2 bg-blue-400 text-white font-bold rounded-lg shadow hover:bg-green-400 transition duration-200">
      Show Rules üìú
    </button>

    <h2 class="text-3xl font-bold text-gray-800 mb-6">Race TracküèÅ</h2>

    <!-- Player Management -->
    <div class="mb-8 w-full">
      <h3 class="text-2xl font-semibold text-gray-700 mb-4">Players (<span id="playerCount">0</span>/4)</h3>
      <div id="stagedPlayersContainer" class="flex flex-wrap justify-center gap-x-4 gap-y-2 mb-4">
        </div>
      <div class="flex justify-center gap-4">
        <button id="addPlayerButton" onclick="addPlayer()" class="px-6 py-2 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition duration-200">Add Player</button>
        <button id="removePlayerButton" onclick="removePlayer()" class="px-6 py-2 bg-red-500 text-white font-bold rounded-lg shadow-md hover:bg-red-600 transition duration-200">Remove Player</button>
      </div>
    </div>

    <!-- Track Selection -->
    <div class="w-full">
      <h3 class="text-2xl font-semibold text-gray-700 mb-4">Select Track</h3>
      <div id="trackSelectionContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
        </div>
    </div>

    <button onclick="startGame()" class="px-10 py-4 bg-blue-600 text-white font-bold text-xl rounded-lg shadow-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105">Start Race! üèÅ</button>
  </div>

  <!-- Game Screen (initially hidden) -->
  <div id="gameScreen" class="hidden w-11/12 mx-auto">
    <div class="game-container">
      <div class="track-container">
        <canvas id="track" width="900" height="600" class="max-w-full h-auto"></canvas>
        <div class="flex justify-center mt-4">
          <button id="resetButton" onclick="resetGame()" class="px-8 py-3 bg-red-500 text-white font-bold rounded-lg shadow-lg hover:bg-red-600 transition duration-200 ease-in-out transform hover:scale-105">üîÑ Reset Game</button>
        </div>
      </div>

      <div class="controls-container">
        <div id="playerList" class="mb-6">
          <h3 class="font-bold text-gray-800 mb-2">Players:</h3>
          <div id="playersContainer" class="player-list">
            </div>
        </div>
        
        <div class="mb-4">
          <h3 id="currentTurnInfo" class="text-xl font-bold text-gray-800 mb-2">Player 1's Turn</h3>
          <p id="gameStatusInfo" class="text-lg font-medium text-gray-700 mb-4">Status: Playing</p>
        </div>

        <div class="mb-4">
          <h4 class="text-lg font-semibold text-gray-700 mb-2">Current Velocity: <span id="velocity">(0, 0)</span></h4>
        </div>

        <!-- Movement Controls -->
        <div class="mb-4">
          <h4 class="text-lg font-semibold text-gray-700 mb-2">Choose Your Move:</h4>
          <div id="movementControl" class="grid grid-cols-3 gap-1 w-48 h-48 bg-gray-200 p-2 rounded-lg mx-auto">
            </div>
          <div class="flex justify-center gap-4 mt-4">
            <button id="clearSelectionButton" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded" onclick="clearSelectedMove()">Clear Selection</button>
            <button id="confirmMoveButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded" onclick="confirmMove()">Confirm Move</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Message Box -->
  <div id="messageBoxOverlay" class="message-box-overlay hidden">
    <div id="messageBoxContent" class="message-box-content">
      <p id="messageBoxText" class="text-lg font-medium text-gray-800 mb-6"></p>
      <button onclick="hideMessageBox()" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 ease-in-out transform hover:scale-105">OK</button>
    </div>
  </div>


  <script>
    const canvas = document.getElementById("track");
    const ctx = canvas.getContext("2d");
    const gridSize = 30; // Size of each grid cell in pixels
    const cols = canvas.width / gridSize; // Number of columns in the grid
    const rows = canvas.height / gridSize; // Number of rows in the grid

    // Player colors for multiplayer
    const playerColors = [
      "#3B82F6", // Player 1: Blue
      "#EF4444", // Player 2: Red
      "#10B981", // Player 3: Green
      "#F59E0B"  // Player 4: Amber
    ];

    // SVG icon paths for directions
    const svgIcons = {
        'up-left': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(135 12 12)"/>',
        'up': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(270 12 12)"/>',
        'up-right': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(45 12 12)"/>',
        'left': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(180 12 12)"/>',
        'hold': '<circle cx="12" cy="12" r="4"/>',
        'right': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(0 12 12)"/>',
        'down-left': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(-135 12 12)"/>',
        'down': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(90 12 12)"/>',
        'down-right': '<path d="M12 19L5 12L12 5M5 12H19" transform="rotate(-45 12 12)"/>',
    };

    /**
     * Helper function to get the correct SVG icon string based on dx and dy for *visual movement*.
     */
    function getDirectionIcon(dx, dy) {
        if (dx === 0 && dy === 0) return svgIcons['hold'];
        if (dx === 0 && dy === -1) return svgIcons['down'];
        if (dx === 0 && dy === 1) return svgIcons['up'];
        if (dx === -1 && dy === 0) return svgIcons['right'];
        if (dx === 1 && dy === 0) return svgIcons['left'];
        if (dx === -1 && dy === -1) return svgIcons['up-right'];
        if (dx === 1 && dy === -1) return svgIcons['up-left'];
        if (dx === -1 && dy === 1) return svgIcons['down-right'];
        if (dx === 1 && dy === 1) return svgIcons['down-left'];
        return '';
    }

    // --- Helper Functions for Track Drawing ---

    /**
     * Fills a rectangular area with blocks (walls).
     */
    function addBlock(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          blockedCells.add(cellKey(x, y));
        }
      }
    }

    /**
     * Unblocks a rectangular area, creating a path.
     */
    function unblockRectangle(startX, startY, width, height) {
        for (let x = startX; x < startX + width; x++) {
            for (let y = startY; y < startY + height; y++) {
                blockedCells.delete(cellKey(x, y));
            }
        }
    }

    /**
     * Unblocks a diagonal line segment with a given thickness.
     */
    function unblockDiagonal(x0, y0, x1, y1, thickness = 1) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;

        let currentX = x0;
        let currentY = y0;

        while (true) {
            // Unblock a small rectangle at current position
            for (let i = 0; i < thickness; i++) {
                for (let j = 0; j < thickness; j++) {
                    blockedCells.delete(cellKey(currentX + i, currentY + j));
                }
            }

            if (currentX === x1 && currentY === y1) break;

            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; currentX += sx; }
            if (e2 < dx) { err += dx; currentY += sy; }
        }
    }

    /**
     * Helper function to define the core playable area bounds for letter tracks.
     */
    function getPlayableAreaBounds() {
        const playableMinX = 2;
        const playableMaxX = cols - 3;
        const playableMinY = 2;
        const playableMaxY = rows - 3;
        return { playableMinX, playableMaxX, playableMinY, playableMaxY };
    }

    /**
     * Draws Start/Finish lines and text for alphabet tracks.
     */
    function drawTrackLinesAndTexts(startLine, finishLine) {
        // Draw Start Line
        ctx.strokeStyle = "#10B981"; // Green
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(startLine.x0 * gridSize, startLine.y0 * gridSize);
        ctx.lineTo(startLine.x1 * gridSize, startLine.y1 * gridSize);
        ctx.stroke();

        ctx.font = "14px Inter";
        ctx.fillStyle = "#10B981";
        if (startLine.type === 'horizontal') {
            const textYOffset = (startLine.y0 < (rows / 2)) ? 15 : -5;
            ctx.fillText("START", (startLine.x0 + (startLine.x1 - startLine.x0) / 2) * gridSize - 20, startLine.y0 * gridSize + textYOffset);
        } else {
            ctx.fillText("START", (startLine.x0 + 0.5) * gridSize, (startLine.y0 + 1) * gridSize);
        }

        // Draw Finish Line
        ctx.strokeStyle = "#EF4444"; // Red
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(finishLine.x0 * gridSize, finishLine.y0 * gridSize);
        ctx.lineTo(finishLine.x1 * gridSize, finishLine.y1 * gridSize);
        ctx.stroke();

        ctx.font = "14px Inter";
        ctx.fillStyle = "#EF4444";
        if (finishLine.type === 'horizontal') {
            const textYOffset = (finishLine.y0 < (rows / 2)) ? 15 : -5;
            ctx.fillText("FINISH", (finishLine.x0 + (finishLine.x1 - finishLine.x0) / 2) * gridSize - 20, finishLine.y0 * gridSize + textYOffset);
        } else {
            ctx.fillText("FINISH", (finishLine.x1 + 0.5) * gridSize - 50, (finishLine.y1 + 1) * gridSize);
        }
    }

    // --- Track Definitions ---
    const trackDefinitions = [
        {
            id: 'simple-sprint',
            name: 'Simple Sprint',
            description: 'A straightforward track with a wide, clear path.',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

                // Fill entire inner playable area with walls first
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                // Unblock a wide, straight path
                unblockRectangle(playableMinX, playableMinY, playableMaxX - playableMinX + 1, playableMaxY - playableMinY + 1);

                // Define Start and Finish Line coordinates
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMaxY, type: 'vertical' };
                const finishLine = { x0: playableMaxX, y0: playableMinY, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'z-track',
            name: 'Z-Track',
            description: 'Navigate a challenging Z-shaped path (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

                // Fill entire inner playable area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4;
                const letterWidth = playableMaxX - playableMinX + 1;

                // Top horizontal bar of Z
                unblockRectangle(playableMinX, playableMinY, letterWidth, pathWidth);

                // Diagonal stroke
                unblockDiagonal(playableMaxX - pathWidth + 1, playableMinY, playableMinX, playableMaxY - pathWidth + 1, pathWidth);

                // Bottom horizontal bar of Z
                unblockRectangle(playableMinX, playableMaxY - pathWidth + 1, letterWidth, pathWidth);

                // Define Start and Finish Line coordinates
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMinY + pathWidth -1, type: 'vertical' };
                const finishLine = { x0: playableMaxX, y0: playableMaxY - pathWidth + 1, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'h-track',
            name: 'H-Track',
            description: 'Race through an H-shaped track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4;
                const letterWidth = playableMaxX - playableMinX + 1;
                const letterHeight = playableMaxY - playableMinY + 1;

                // Left vertical bar
                unblockRectangle(playableMinX, playableMinY, pathWidth, letterHeight);

                // Right vertical bar
                unblockRectangle(playableMaxX - pathWidth + 1, playableMinY, pathWidth, letterHeight);

                // Horizontal connecting bar (middle)
                unblockRectangle(playableMinX, Math.floor(playableMinY + letterHeight / 2) - Math.floor(pathWidth / 2), letterWidth, pathWidth);

                // Define Start and Finish Line coordinates
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX + pathWidth -1, y1: playableMinY, type: 'horizontal' };
                const finishLine = { x0: playableMaxX - pathWidth + 1, y0: playableMaxY, x1: playableMaxX, y1: playableMaxY, type: 'horizontal' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
        {
            id: 'u-track',
            name: 'U-Track',
            description: 'Turn around a U-shaped track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4;
                const letterHeight = playableMaxY - playableMinY + 1;
                const letterWidth = playableMaxX - playableMinX + 1;

                // Left vertical arm
                unblockRectangle(playableMinX, playableMinY, pathWidth, letterHeight);

                // Right vertical arm
                unblockRectangle(playableMaxX - pathWidth + 1, playableMinY, pathWidth, letterHeight);

                // Bottom connecting curve/bar
                unblockRectangle(playableMinX, playableMaxY - pathWidth + 1, letterWidth, pathWidth);

                // Define Start and Finish Line coordinates
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX + pathWidth -1, y1: playableMinY, type: 'horizontal' };
                const finishLine = { x0: playableMaxX - pathWidth + 1, y0: playableMinY, x1: playableMaxX, y1: playableMinY, type: 'horizontal' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        },
      {
    id: 'sigma-track',
    name: 'M shaped Track',
    description: 'M-shape with smooth curves',
    drawLayout: () => {
        blockedCells.clear();
        const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

        // 1. Create outer walls
        addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
        addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

        // 2. Fill play area with walls
        for (let x = playableMinX; x <= playableMaxX; x++) {
            for (let y = playableMinY; y <= playableMaxY; y++) {
                blockedCells.add(cellKey(x, y));
            }
        }

        const pathWidth = 5;
        const letterHeight = playableMaxY - playableMinY + 1;
        const letterWidth = playableMaxX - playableMinX + 1;

        // 3. Sigma shape points (rotated M)
        const points = [
            // Start at bottom-left
            { x: playableMinX, y: playableMaxY },
            // First peak (left)
            { x: Math.floor(playableMinX + letterWidth * 0.25), y: playableMinY },
            // Valley (center)
            { x: Math.floor(playableMinX + letterWidth * 0.5), y: Math.floor(playableMinY + letterHeight * 0.5) },
            // Second peak (right)
            { x: Math.floor(playableMinX + letterWidth * 0.75), y: playableMinY },
            // Finish at bottom-right (original position)
            { x: playableMaxX, y: playableMaxY }
        ];

        // 4. Create 5-cell wide diagonal paths
        for (let i = 0; i < points.length - 1; i++) {
            unblockDiagonal(
                points[i].x, points[i].y,
                points[i+1].x, points[i+1].y,
                pathWidth
            );
        }

        // 5. Define start/finish lines (vertical)
        const startLine = {
            x0: points[0].x,
            y0: points[0].y - Math.floor(pathWidth/2),
            x1: points[0].x,
            y1: points[0].y + Math.floor(pathWidth/2),
            type: 'vertical'
        };

        // Modified finish line - moved 2 grids right from original edge
        const finishLine = {
            x0: points[4].x + 2,  // Key change: +2 to x-position
            y0: points[4].y - Math.floor(pathWidth/2),
            x1: points[4].x + 2,  // Consistent x-position
            y1: points[4].y + Math.floor(pathWidth/2),
            type: 'vertical'
        };

        // 6. Ensure finish area is clear
        for (let y = finishLine.y0; y <= finishLine.y1; y++) {
            blockedCells.delete(cellKey(finishLine.x0, y));
            blockedCells.delete(cellKey(finishLine.x0 + 1, y)); // Clear adjacent cells
        }

        // 7. Draw track markers
        drawTrackLinesAndTexts(startLine, finishLine);
        return { startLine, finishLine };
    }
},
        {
            id: 's-track',
            name: 'Stairs Track',
            description: 'Test your turning skills on the classic S-bend track (white area).',
            drawLayout: () => {
                blockedCells.clear();
                const { playableMinX, playableMaxX, playableMinY, playableMaxY } = getPlayableAreaBounds();

                // Outer boundaries
                addBlock(0, 0, cols, 2); addBlock(0, rows - 2, cols, 2);
                addBlock(0, 0, 2, rows); addBlock(cols - 2, 0, 2, rows);

                // Fill inner area with walls
                for (let x = playableMinX; x <= playableMaxX; x++) {
                    for (let y = playableMinY; y <= playableMaxY; y++) {
                        blockedCells.add(cellKey(x, y));
                    }
                }

                const pathWidth = 4;

                // Calculate center points for S-curve
                const midX = Math.floor(playableMinX + (playableMaxX - playableMinX) / 2);
                const midY = Math.floor(playableMinY + (playableMaxY - playableMinY) / 2);

                // S-shape unblocking
                // Part 1: Top-left vertical segment
                unblockRectangle(playableMinX, playableMinY, pathWidth, midY - playableMinY + pathWidth / 2);

                // Part 2: Diagonal from top-left area to bottom-right area
                unblockDiagonal(playableMinX, midY, playableMaxX - pathWidth + 1, playableMaxY - pathWidth + 1, pathWidth);

                // Part 3: Bottom-right vertical segment
                unblockRectangle(playableMaxX - pathWidth + 1, midY - pathWidth / 2, pathWidth, playableMaxY - midY + pathWidth / 2 + 1);

                // Define Start and Finish Line coordinates
                const startLine = { x0: playableMinX, y0: playableMinY, x1: playableMinX, y1: playableMinY + pathWidth, type: 'vertical' };
                const finishLine = { x0: playableMaxX, y0: playableMaxY - pathWidth, x1: playableMaxX, y1: playableMaxY, type: 'vertical' };
                drawTrackLinesAndTexts(startLine, finishLine);
                return { startLine, finishLine };
            }
        }
    ];

    // --- Game State and Setup Variables ---
    let stagedPlayers = [];
    let selectedTrackId = trackDefinitions[0].id;

    // Game state variables
    let gameState = {
      players: [],
      currentPlayerIndex: 0,
      gameStatus: 'playing',
      finishedPlayers: [],
      winnerIndex: null,
      turnCount: 0
    };

    let blockedCells = new Set();
    let flashing = false;
    let animationFrameId = null;

    // Global variables to store the selected target velocity
    let selectedVx = 0;
    let selectedVy = 0;

    // --- Custom Message Box Functions ---
    const messageBoxOverlay = document.getElementById('messageBoxOverlay');
    const messageBoxText = document.getElementById('messageBoxText');
    const messageBoxContent = document.getElementById('messageBoxContent');
    let messageBoxCallback = null;

    function showMessageBox(message, type = "info", callback = null) {
      if (!messageBoxOverlay || !messageBoxText || !messageBoxContent) {
          console.error("Message box elements not found in DOM yet. Cannot display message:", message);
          return;
      }
      messageBoxText.innerText = message;
      messageBoxOverlay.classList.remove('hidden');
      messageBoxCallback = callback;
      if (type === 'error') {
        messageBoxContent.style.border = '2px solid #EF4444';
      } else if (type === 'success') {
        messageBoxContent.style.border = '2px solid #10B981';
      } else {
        messageBoxContent.style.border = 'none';
      }
    }

    function hideMessageBox() {
      if (!messageBoxOverlay) return;
      messageBoxOverlay.classList.add('hidden');
      if (messageBoxCallback) {
        messageBoxCallback();
        messageBoxCallback = null;
      }
    }

    // --- Utility Functions ---
    function cellKey(x, y) {
      return `${x},${y}`;
    }

    function setControlButtonsState(enableMovementGrid, enableConfirmMoveButton, enableClearSelectionButton) {
        const confirmMoveBtn = document.getElementById('confirmMoveButton');
        if (confirmMoveBtn) {
            confirmMoveBtn.disabled = !enableConfirmMoveButton;
        }

        const clearSelectionBtn = document.getElementById('clearSelectionButton');
        if (clearSelectionBtn) {
            clearSelectionBtn.disabled = !enableClearSelectionButton;
        }

        const movementControlDiv = document.getElementById('movementControl');
        if (movementControlDiv) {
            if (enableMovementGrid) {
                movementControlDiv.classList.remove('pointer-events-none', 'opacity-50');
            } else {
                movementControlDiv.classList.add('pointer-events-none', 'opacity-50');
            }
        }
    }

    // --- Drawing Functions ---
    function drawGrid() {
      ctx.strokeStyle = "#E5E7EB";
      ctx.lineWidth = 1;
      for (let x = 0; x <= cols; x++) {
        const px = x * gridSize;
        ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke();
      }
      for (let y = 0; y <= rows; y++) {
        const py = y * gridSize;
        ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke();
      }
    }

    function drawTrackArea() {
      const selectedTrack = trackDefinitions.find(t => t.id === selectedTrackId);
      if (selectedTrack) {
          selectedTrack.drawLayout();
      } else {
          trackDefinitions[0].drawLayout();
      }

      // Draw all blocked cells (walls)
      ctx.fillStyle = "#4B5563";
      blockedCells.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
      });
    }

    function showNextMovePreview() {
      const currentPlayer = gameState.players[gameState.currentPlayerIndex];
      if (!currentPlayer || currentPlayer.hasFinished || gameState.gameStatus === 'finished') return;

      if (!currentPlayer.hasChangedVelocityThisTurn || currentPlayer.isAnimating) {
          return;
      }

      const nx = currentPlayer.x + selectedVx;
      const ny = currentPlayer.y + selectedVy;
      ctx.fillStyle = "rgba(59, 130, 246, 0.4)";
      ctx.beginPath();
      ctx.arc(nx * gridSize, ny * gridSize, 7, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawPlayers(timestamp) {
        if (!gameState.players || gameState.players.length === 0) return;

        gameState.players.forEach((p, index) => {
            let currentDrawX = p.x;
            let currentDrawY = p.y;

            if (p.isAnimating && p.animationStartTime !== null) {
                const elapsed = timestamp - p.animationStartTime;
                const progress = Math.min(elapsed / p.animationDuration, 1);

                currentDrawX = p.animationStartPos[0] + (p.animationEndPos[0] - p.animationStartPos[0]) * progress;
                currentDrawY = p.animationStartPos[1] + (p.animationEndPos[1] - p.animationStartPos[1]) * progress;

                if (progress === 1) {
                    p.isAnimating = false;
                    p.animationStartTime = null;
                    p.x = p.animationEndPos[0];
                    p.y = p.animationEndPos[1];
                    if (!p.isCrashAnimation) {
                        p.path.push([p.x, p.y]);
                    }
                    if (p.animationCompletionCallback) {
                        p.animationCompletionCallback();
                        p.animationCompletionCallback = null;
                        p.isCrashAnimation = false;
                    }
                }
            }

            ctx.strokeStyle = p.color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (p.path && p.path.length > 0) {
                p.path.forEach(([x, y], i) => {
                    const px = x * gridSize;
                    const py = y * gridSize;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
            }
            if (p.isAnimating) {
                ctx.lineTo(currentDrawX * gridSize, currentDrawY * gridSize);
            }
            ctx.stroke();

            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(currentDrawX * gridSize, currentDrawY * gridSize, 5, 0, 2 * Math.PI);
            ctx.fill();

            if (index === gameState.currentPlayerIndex && gameState.gameStatus === 'playing') {
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(currentDrawX * gridSize, currentDrawY * gridSize, 8, 0, 2 * Math.PI);
                ctx.stroke();
            }
        });

        if (gameState.players.some(p => p.isAnimating)) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        } else {
            animationFrameId = null;
        }
    }

    function animateGameLoop(timestamp) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawTrackArea();
        drawPlayers(timestamp);
        showNextMovePreview();
    }

    function render() {
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }

function drawMovementSelectionGrid() {
    const movementControl = document.getElementById('movementControl');
    if (!movementControl) return;

    movementControl.innerHTML = '';

    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    const areControlsActive = (currentPlayer && !currentPlayer.hasFinished && 
                             gameState.gameStatus === 'playing' && !currentPlayer.isAnimating);

    setControlButtonsState(
        areControlsActive && !currentPlayer.hasChangedVelocityThisTurn,
        areControlsActive && currentPlayer.hasChangedVelocityThisTurn,
        areControlsActive && currentPlayer.hasChangedVelocityThisTurn
    );

    const currentVx = currentPlayer ? currentPlayer.vx : 0;
    const currentVy = currentPlayer ? currentPlayer.vy : 0;

    // Check if player is on start line
    const selectedTrack = trackDefinitions.find(t => t.id === selectedTrackId);
    const { startLine } = selectedTrack.drawLayout();
    const isOnStartLine = isPlayerAtStartLine(currentPlayer, startLine);

    // Generate all 9 movement buttons
    for (let dyGrid = -1; dyGrid <= 1; dyGrid++) {
        for (let dxGrid = -1; dxGrid <= 1; dxGrid++) {
            const targetVx = currentVx + dxGrid;
            const targetVy = currentVy + dyGrid;

            const button = document.createElement('button');
            button.className = 'w-full h-full flex items-center justify-center text-sm font-semibold rounded ' +
                               'transition-colors duration-150 ease-in-out ' +
                               'movement-grid-button';

            button.innerHTML = `
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    ${getDirectionIcon(dxGrid, dyGrid)}
                </svg>
            `;

            button.setAttribute('title', `Change velocity to (${targetVx}, ${targetVy})`);

            // Highlight selected move
            if (selectedVx === targetVx && selectedVy === targetVy && currentPlayer.hasChangedVelocityThisTurn) {
                button.classList.add('selected-move');
            }

            // Disable conditions:
            const isRestrictedOnStartLine = isOnStartLine && (
                (startLine.type === 'vertical' && !(dxGrid === 1 && (dyGrid === -1 || dyGrid === 0 || dyGrid === 1))) ||
                (startLine.type === 'horizontal' && !(dyGrid === 1 && (dxGrid === -1 || dxGrid === 0 || dxGrid === 1)))
            );

            if (!areControlsActive || currentPlayer.hasChangedVelocityThisTurn || isRestrictedOnStartLine) {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                button.onclick = () => selectNextMove(targetVx, targetVy);
            }

            movementControl.appendChild(button);
        }
    }
}
// Helper function to check if player is at start line
function isPlayerAtStartLine(player, startLine) {
    if (startLine.type === 'horizontal') {
        // Check if player is on the horizontal start line (green line)
        const minX = Math.min(startLine.x0, startLine.x1);
        const maxX = Math.max(startLine.x0, startLine.x1);
        return Math.round(player.y) === startLine.y0 && 
               Math.round(player.x) >= minX && 
               Math.round(player.x) <= maxX;
    } else {
        // Check if player is on the vertical start line (green line)
        const minY = Math.min(startLine.y0, startLine.y1);
        const maxY = Math.max(startLine.y0, startLine.y1);
        return Math.round(player.x) === startLine.x0 && 
               Math.round(player.y) >= minY && 
               Math.round(player.y) <= maxY;
    }
}
    function updateGameUI() {
        document.getElementById('gameStatusInfo').innerText = `Status: ${gameState.gameStatus.replace(/_/g, ' ')}`;

        const playersContainer = document.getElementById('playersContainer');
        playersContainer.innerHTML = '';
        gameState.players.forEach((p, index) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = `player-item ${index === gameState.currentPlayerIndex ? 'current' : ''} ${p.hasFinished ? 'finished' : ''}`;
            
            const colorBox = document.createElement('span');
            colorBox.className = 'player-indicator';
            colorBox.style.backgroundColor = p.color;
            playerDiv.appendChild(colorBox);
            playerDiv.appendChild(document.createTextNode(`Player ${index + 1}`));
            
            playersContainer.appendChild(playerDiv);
        });

        if (gameState.players.length > 0) {
            document.getElementById('currentTurnInfo').innerText = `Player ${gameState.currentPlayerIndex + 1}'s Turn`;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            document.getElementById("velocity").innerText = `(${currentPlayer.vx}, ${currentPlayer.vy})`;
        } else {
            document.getElementById('currentTurnInfo').innerText = "Game not initialized.";
            document.getElementById("velocity").innerText = `(0, 0)`;
        }

        drawMovementSelectionGrid();

        if (gameState.gameStatus === 'finished' && gameState.winnerIndex !== null) {
            setControlButtonsState(false, false, false);
        }
    }

    // --- Game Logic Functions ---
    function tracePathAndFindCollision(startX, startY, endX, endY, currentPlayerId) {
        let lastValidX = startX;
        let lastValidY = startY;
        let didCrash = false;
        let collisionType = null;
        let collidedWithPlayerId = null;

        const dx = Math.abs(endX - startX);
        const dy = Math.abs(endY - startY);
        const sx = (startX < endX) ? 1 : -1;
        const sy = (startY < endY) ? 1 : -1;
        let err = dx - dy;

        let currentX = startX;
        let currentY = startY;

        while (true) {
            if (currentX < 0 || currentX >= cols || currentY < 0 || currentY >= rows || blockedCells.has(cellKey(currentX, currentY))) {
                didCrash = true;
                collisionType = 'wall';
                break;
            }

            if (!(currentX === startX && currentY === startY)) {
                const otherPlayer = gameState.players.find(p =>
                    p.id !== currentPlayerId && 
                    Math.round(p.x) === Math.round(currentX) && 
                    Math.round(p.y) === Math.round(currentY)
                );
                if (otherPlayer) {
                    didCrash = true;
                    collisionType = 'player';
                    collidedWithPlayerId = otherPlayer.id;
                    break;
                }
            }

            lastValidX = currentX;
            lastValidY = currentY;

            if (currentX === endX && currentY === endY) break;

            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                currentX += sx;
            }
            if (e2 < dx) {
                err += dx;
                currentY += sy;
            }
        }
        return { x: lastValidX, y: lastValidY, didCrash, collisionType, collidedWithPlayerId };
    }

    function selectNextMove(newVx, newVy) {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer || currentPlayer.hasFinished || gameState.gameStatus !== 'playing') return;

        currentPlayer.previousVx = currentPlayer.vx;
        currentPlayer.previousVy = currentPlayer.vy;

        currentPlayer.vx = newVx;
        currentPlayer.vy = newVy;
        currentPlayer.hasChangedVelocityThisTurn = true;

        selectedVx = newVx;
        selectedVy = newVy;

        updateGameUI();
        render();
    }

    async function confirmMove() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer || currentPlayer.isAnimating || gameState.gameStatus !== 'playing' || !currentPlayer.hasChangedVelocityThisTurn) {
            console.warn("Attempted to confirm move in an invalid state.");
            return;
        }

        await movePlayer();
    }

    function clearSelectedMove() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer || currentPlayer.isAnimating || gameState.gameStatus !== 'playing') return;

        currentPlayer.vx = currentPlayer.previousVx;
        currentPlayer.vy = currentPlayer.previousVy;
        currentPlayer.hasChangedVelocityThisTurn = false;

        selectedVx = currentPlayer.vx;
        selectedVy = currentPlayer.vy;

        updateGameUI();
        render();
    }

    async function advancePlayerTurn() {
        if (gameState.gameStatus === 'finished') return;

        let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
        gameState.turnCount++;

        if (gameState.players[nextPlayerIndex]) {
            gameState.players[nextPlayerIndex].hasChangedVelocityThisTurn = false;
            selectedVx = 0;
            selectedVy = 0;
        }

        let attempts = 0;
        while (gameState.players[nextPlayerIndex].hasFinished && attempts < gameState.players.length) {
            nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
            attempts++;
        }

        if (attempts === gameState.players.length && gameState.players[nextPlayerIndex].hasFinished) {
            return;
        }

        gameState.currentPlayerIndex = nextPlayerIndex;
        updateGameUI();
        render();
    }

    async function handleTurnEnd(isCrash = false) {
        if (gameState.gameStatus === 'finished') return;

        selectedVx = 0;
        selectedVy = 0;

        if (isCrash && gameState.players.length === 1) {
            gameState.players[gameState.currentPlayerIndex].hasChangedVelocityThisTurn = false;
            updateGameUI();
            render();
        } else {
            await advancePlayerTurn();
        }
    }

    async function movePlayer() {
        if (flashing || gameState.gameStatus === 'finished') return;

        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        setControlButtonsState(false, false, false);

        if (currentPlayer.hasFinished) {
            showMessageBox("You have already finished the race! Game is ending.", "info");
            return;
        }

        if (gameState.turnCount >= gameState.players.length && currentPlayer.vx === 0 && currentPlayer.vy === 0) {
            showMessageBox("Velocity (0,0).Please select a non-zero velocity.", "error", () => {
                currentPlayer.hasChangedVelocityThisTurn = false;
                currentPlayer.vx = currentPlayer.previousVx;
                currentPlayer.vy = currentPlayer.previousVy;
                selectedVx = currentPlayer.vx;
                selectedVy = currentPlayer.vy;
                updateGameUI();
                render();
            });
            return;
        }

        const nextPotentialX = currentPlayer.x + currentPlayer.vx;
        const nextPotentialY = currentPlayer.y + currentPlayer.vy;

        const collisionResult = tracePathAndFindCollision(
            currentPlayer.x,
            currentPlayer.y,
            nextPotentialX,
            nextPotentialY,
            currentPlayer.id
        );

        let crashOccurred = collisionResult.didCrash;
        let crashMessage = "";
        let finalPlayerX = collisionResult.x;
        let finalPlayerY = collisionResult.y;

        if (collisionResult.collisionType === 'player') {
            showMessageBox(`WARNING! Player ${gameState.currentPlayerIndex + 1} cannot move to (${nextPotentialX}, ${nextPotentialY}) because another player is there. Please adjust your velocity.`, "info", () => {
                currentPlayer.hasChangedVelocityThisTurn = false;
                currentPlayer.vx = currentPlayer.previousVx;
                currentPlayer.vy = currentPlayer.previousVy;
                selectedVx = currentPlayer.vx;
                selectedVy = currentPlayer.vy;
                updateGameUI();
                render();
            });
            return;
        }

        const currentTrack = trackDefinitions.find(t => t.id === selectedTrackId);
        const { finishLine } = currentTrack.drawLayout();

        let crossedFinishLine = false;
        if (finishLine.type === 'horizontal') {
            const minX = Math.min(finishLine.x0, finishLine.x1);
            const maxX = Math.max(finishLine.x0, finishLine.x1);
            const yThreshold = finishLine.y0;

            if (yThreshold < (rows / 2)) {
                crossedFinishLine = (nextPotentialY <= yThreshold) && (nextPotentialX >= minX && nextPotentialX <= maxX);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = yThreshold - nextPotentialY;
                }
            } else {
                crossedFinishLine = (nextPotentialY >= yThreshold) && (nextPotentialX >= minX && nextPotentialX <= maxX);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = nextPotentialY - yThreshold;
                }
            }
        } else {
            const minY = Math.min(finishLine.y0, finishLine.y1);
            const maxY = Math.max(finishLine.y0, finishLine.y1);
            const xThreshold = finishLine.x0;

            if (xThreshold < (cols / 2)) {
                crossedFinishLine = (nextPotentialX <= xThreshold) && (nextPotentialY >= minY && nextPotentialY <= maxY);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = xThreshold - nextPotentialX;
                }
            } else {
                crossedFinishLine = (nextPotentialX >= xThreshold) && (nextPotentialY >= minY && nextPotentialY <= maxY);
                if (crossedFinishLine) {
                    currentPlayer.distancePastFinishLine = nextPotentialX - xThreshold;
                }
            }
        }

        if (crossedFinishLine) {
            currentPlayer.hasFinished = true;
            gameState.gameStatus = 'finished';

            finalPlayerX = nextPotentialX;
            finalPlayerY = nextPotentialY;

            currentPlayer.isAnimating = true;
            currentPlayer.animationStartTime = performance.now();
            currentPlayer.animationDuration = 300;
            currentPlayer.animationStartPos = [currentPlayer.x, currentPlayer.y];
            currentPlayer.animationEndPos = [finalPlayerX, finalPlayerY];
            currentPlayer.isCrashAnimation = false;

            currentPlayer.animationCompletionCallback = async () => {
                currentPlayer.path.push([currentPlayer.x, currentPlayer.y]);
                await determineWinner();
            };
        } else if (crashOccurred) {
            crashMessage = "CRASH! You hit a wall or went out of bounds. Velocity reset. Your position reverted to the closest valid spot.";
            currentPlayer.vx = 0;
            currentPlayer.vy = 0;

            currentPlayer.isAnimating = true;
            currentPlayer.animationStartTime = performance.now();
            currentPlayer.animationDuration = 300;
            currentPlayer.animationStartPos = [currentPlayer.x, currentPlayer.y];
            currentPlayer.animationEndPos = [finalPlayerX, finalPlayerY];
            currentPlayer.isCrashAnimation = true;

            currentPlayer.animationCompletionCallback = async () => {
                await flashCrash(nextPotentialX, nextPotentialY);
                showMessageBox(crashMessage, "error", async () => {
                    updateGameUI();
                    await handleTurnEnd(true);
                });
            };
        } else {
            currentPlayer.isAnimating = true;
            currentPlayer.animationStartTime = performance.now();
            currentPlayer.animationDuration = 300;
            currentPlayer.animationStartPos = [currentPlayer.x, currentPlayer.y];
            currentPlayer.animationEndPos = [nextPotentialX, nextPotentialY];
            currentPlayer.isCrashAnimation = false;

            currentPlayer.animationCompletionCallback = async () => {
                currentPlayer.path.push([currentPlayer.x, currentPlayer.y]);
                currentPlayer.lastValidX = currentPlayer.x;
                currentPlayer.lastValidY = currentPlayer.y;
                await handleTurnEnd(false);
            };
        }

        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }

    async function determineWinner() {
        let winningPlayerIndex = null;
        let bestDistance = -Infinity;

        const finishedRacers = gameState.players.filter(p => p.hasFinished);

        if (finishedRacers.length > 0) {
            for (let i = 0; i < finishedRacers.length; i++) {
                const p = finishedRacers[i];
                if (p.distancePastFinishLine > bestDistance) {
                    bestDistance = p.distancePastFinishLine;
                    winningPlayerIndex = gameState.players.indexOf(p);
                }
            }
        } else {
            winningPlayerIndex = null;
        }

        gameState.gameStatus = 'finished';
        gameState.winnerIndex = winningPlayerIndex;
        updateGameUI();
        render();

        if (winningPlayerIndex !== null) {
            showMessageBox(`Game Over! The winner is Player ${winningPlayerIndex + 1}!`, "success", () => resetGame());
        } else {
            showMessageBox("Game Over! No one crossed the finish line. Try again!", "info", () => resetGame());
        }
    }

    async function flashCrash(x, y) {
      flashing = true;
      let count = 0;
      const interval = setInterval(() => {
        ctx.fillStyle = count % 2 === 0 ? "#EF4444" : "rgba(0,0,0,0)";
        ctx.beginPath();
        ctx.arc(x * gridSize, y * gridSize, 10, 0, 2 * Math.PI);
        ctx.fill();
        count++;
        if (count >= 6) {
          clearInterval(interval);
          flashing = false;
          render();
        }
      }, 100);
      return new Promise(resolve => setTimeout(() => resolve(), 600));
    }

    function resetGame() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        document.getElementById('gameScreen').classList.add('hidden');
        document.getElementById('setupScreen').classList.remove('hidden');

        stagedPlayers = [];
        addPlayer();
        selectedTrackId = trackDefinitions[0].id;
        renderSetupScreen();

        const confirmMoveBtn = document.getElementById('confirmMoveButton');
        if (confirmMoveBtn) confirmMoveBtn.disabled = true;
        const clearSelectionBtn = document.getElementById('clearSelectionButton');
        if (clearSelectionBtn) clearSelectionBtn.disabled = true;
        const movementControlDiv = document.getElementById('movementControl');
        if (movementControlDiv) {
            movementControlDiv.classList.add('pointer-events-none', 'opacity-50');
        }

        gameState.players = [];
        gameState.currentPlayerIndex = 0;
        gameState.gameStatus = 'setup';
        gameState.finishedPlayers = [];
        gameState.winnerIndex = null;
        gameState.turnCount = 0;
        selectedVx = 0;
        selectedVy = 0;

        showMessageBox("Game has been reset! Choose track to start a new race.", "info");
    }

    // --- Game Initialization & Setup Screen Logic ---
    function initGame() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        gameState.players = [];
        gameState.currentPlayerIndex = 0;
        gameState.gameStatus = 'playing';
        gameState.finishedPlayers = [];
        gameState.winnerIndex = null;
        gameState.turnCount = 0;

        selectedVx = 0;
        selectedVy = 0;

        const selectedTrack = trackDefinitions.find(t => t.id === selectedTrackId);
        let trackLines = { startLine: {}, finishLine: {} };
        if (selectedTrack) {
            trackLines = selectedTrack.drawLayout();
        } else {
            trackDefinitions[0].drawLayout();
        }

         const startLine = trackLines.startLine;

    stagedPlayers.forEach((p, i) => {
        let playerStartX, playerStartY;
        const numPlayers = stagedPlayers.length;

        if (startLine.type === 'horizontal') {
            // Horizontal start line: Place players ON the line (y = startLine.y0)
            playerStartY = startLine.y0;
            const segmentLength = startLine.x1 - startLine.x0;
            playerStartX = startLine.x0 + ((i + 0.5) / numPlayers) * segmentLength;
        } else {
            // Vertical start line: Place players ON the line (x = startLine.x0)
            playerStartX = startLine.x0;
            const segmentLength = startLine.y1 - startLine.y0;
            playerStartY = startLine.y0 + ((i + 0.5) / numPlayers) * segmentLength;
        }


            gameState.players.push({
                id: p.id,
                x: Math.round(playerStartX),
                y: Math.round(playerStartY),
                vx: 0,
                vy: 0,
                previousVx: 0,
                previousVy: 0,
                path: [[Math.round(playerStartX), Math.round(playerStartY)]],
                color: p.color,
                hasFinished: false,
                distancePastFinishLine: 0,
                lastValidX: Math.round(playerStartX),
                lastValidY: Math.round(playerStartY),
                isAnimating: false,
                animationStartTime: null,
                animationDuration: 300,
                animationStartPos: [Math.round(playerStartX), Math.round(playerStartY)],
                animationEndPos: [Math.round(playerStartX), Math.round(playerStartY)],
                animationCompletionCallback: null,
                isCrashAnimation: false,
                hasChangedVelocityThisTurn: false
            });
        });

        updateGameUI();
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateGameLoop);
        }
    }

    function renderSetupScreen() {
        document.getElementById('playerCount').innerText = stagedPlayers.length;
        document.getElementById('addPlayerButton').disabled = stagedPlayers.length >= 4;
        document.getElementById('removePlayerButton').disabled = stagedPlayers.length === 1;

        const stagedPlayersContainer = document.getElementById('stagedPlayersContainer');
        stagedPlayersContainer.innerHTML = '';
        if (stagedPlayers.length === 0) {
            stagedPlayersContainer.innerHTML = '<p class="text-gray-500">No players added yet.</p>';
        } else {
            stagedPlayers.forEach((p, index) => {
                const li = document.createElement('div');
                li.className = 'flex items-center text-lg font-medium';
                const colorBox = document.createElement('span');
                colorBox.className = 'player-indicator';
                colorBox.style.backgroundColor = p.color;
                li.appendChild(colorBox);
                li.appendChild(document.createTextNode(`Player ${index + 1}`));
                stagedPlayersContainer.appendChild(li);
            });
        }

        const trackSelectionContainer = document.getElementById('trackSelectionContainer');
        trackSelectionContainer.innerHTML = '';
        trackDefinitions.forEach(track => {
            const trackDiv = document.createElement('div');
            trackDiv.id = `track-${track.id}`;
            trackDiv.className = `track-selection-item p-4 rounded-lg cursor-pointer hover:bg-gray-100 transition duration-150 ease-in-out ${selectedTrackId === track.id ? 'selected' : ''}`;
            trackDiv.onclick = () => selectTrack(track.id);
            trackDiv.innerHTML = `
                <h4 class="font-bold text-gray-800 text-lg mb-1">${track.name}</h4>
                <p class="text-sm text-gray-600">${track.description}</p>
            `;
            trackSelectionContainer.appendChild(trackDiv);
        });
    }

    function addPlayer() {
        if (stagedPlayers.length < 4) {
            const newPlayerId = `player${stagedPlayers.length + 1}`;
            const newPlayerColor = playerColors[stagedPlayers.length % playerColors.length];
            stagedPlayers.push({
                id: newPlayerId,
                color: newPlayerColor
            });
            renderSetupScreen();
        } else {
            showMessageBox("Maximum of 4 players allowed.", "info");
        }
    }

    function removePlayer() {
        if (stagedPlayers.length > 1) {
            stagedPlayers.pop();
            renderSetupScreen();
        } else {
            showMessageBox("No players to remove.", "info");
        }
    }

    function selectTrack(trackId) {
        selectedTrackId = trackId;
        renderSetupScreen();
    }
    function showRules() {
    const rules = `
                RULES
                1.Cross the finish line first
                2.Adjust velocity by ¬±1 in x/y each turn
                3.Start by moving away from the green line
                4.Crash into walls resets your speed to (0,0)
                5.Farthest past finish line wins
          
    `;
    showMessageBox(rules, "info");
}

    function startGame() {
        if (stagedPlayers.length === 0) {
            showMessageBox("Please add at least one player to start the game.", "error");
            return;
        }
        if (!selectedTrackId) {
            showMessageBox("Please select a track before starting the game.", "error");
            return;
        }

        document.getElementById('setupScreen').classList.add('hidden');
        document.getElementById('gameScreen').classList.remove('hidden');

        initGame();
    }

    window.onload = function() {
        addPlayer();
        selectTrack(trackDefinitions[0].id);
        renderSetupScreen();

        const confirmMoveBtn = document.getElementById('confirmMoveButton');
        if (confirmMoveBtn) confirmMoveBtn.disabled = true;
        const clearSelectionBtn = document.getElementById('clearSelectionButton');
        if (clearSelectionBtn) clearSelectionBtn.disabled = true;
        const movementControlDiv = document.getElementById('movementControl');
        if (movementControlDiv) {
            movementControlDiv.classList.add('pointer-events-none', 'opacity-50');
        }
    };

    window.addPlayer = addPlayer;
    window.removePlayer = removePlayer;
    window.selectTrack = selectTrack;
    window.startGame = startGame;
    window.confirmMove = confirmMove;
    window.clearSelectedMove = clearSelectedMove;
    window.resetGame = resetGame;
    window.hideMessageBox = hideMessageBox;
    window.showMessageBox = showMessageBox;
    window.showRules = showRules;
  </script>
</body>
</html>